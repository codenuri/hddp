// 핵심 1. 변하지 않은 코드에서 변하는 것을 분리하는 것

// 변하는 것을 가상함수로    : template method. draw() / draw_imp()
// 변하는 것을 다른 클래스로 : strategy         Edit/IValidator 예제
//			템플릿 인자로 교체 : policy base,  vector 와 allocator


// 2. 중첩된 포함(재귀 포함)
//    => A는 B를 포함하지만 A 자신도 포함한다
//    => A와 B는 공통의 기반 클래스 포함
// 왜, 어떤의도로 재귀적인 포함을 하는가 ?
// 
// 재귀적 포함으로 복합객체를 만드는 것 : composite 
// 재귀적 포함으로 객체에 기능 추가    : decorator

// 3. 주어진 문제를 해결하기위해 간접층(중간층)을 제공하자는 것
// => 왜??? 어떤의도로 간접층을 만들었는가 ?
// 
// 사용자 ========= stack  ============> list
//							=> 인터페이스의 변경을 위한 중간층
//							=> adapter
// 
// 사용자 ========= MP3    ============> IMP3
//							=> 구현층과 사용하는계층의 독립적인 update
//							=> bridge
// 
// 사용자 ========= TCPServer ============> Socket, IPAddress
//							=> 사용하기 쉽게
//							=> facade
// 
// 사용자 ========= CalcProxy =========> CalcServer
//							=> 가장 범용적인 용도의 대행자
//							=> proxy

// 4. 통보, 열거,방문
// 1개 객체의 변화를 N개 객체에 전달 : observer
// 복합객체를 동일한 방법으로 열거     : iterator
// 복합객체를 동일한 방법으로 연산 수행 : visitor
// 문제를 해결할때 까지 계속 옆의 객체로 이동 : chain of responsibility


// 5. 어떻게 객체를 만들것인가 ???
// 지금부터..!!